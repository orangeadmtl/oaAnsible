#!/bin/bash
# OrangeAd Autonomous MPV Player - Configuration-driven with real-time display adaptation
# Enhanced with autonomous display management and synchronized dual-screen support

set -e

# Set proper PATH for LaunchAgent environment
export PATH="/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/homebrew/bin:$PATH"

PLAYER_DIR="{{ player.video_source }}"
LOGS_DIR="${PLAYER_DIR}/logs"
LOG_FILE="${LOGS_DIR}/player.log"

# === CONFIGURATION RESOLUTION ===
# Multi-level configuration with autonomous capabilities

# Display management strategy
DISPLAY_STRATEGY="{{ player.display_strategy | default('hybrid') }}"  # config|auto|hybrid
DUAL_SCREEN_CONFIG="{{ player.dual_screen | default('auto') | lower }}"       # true|false|auto
DETECTION_INTERVAL="{{ player.display_detection_interval | default(2) }}"
DISPLAY_MIN_COUNT="{{ player.display_min_count | default(1) }}"
DISPLAY_MAX_COUNT="{{ player.display_max_count | default(2) }}"
STARTUP_SYNC_DELAY="{{ player.startup_sync_delay | default(0.1) }}"
DISPLAY_DEBOUNCE_TIME="{{ player.display_debounce_time | default(3) }}"

# MPV arguments
MPV_ARGS="--loop --fullscreen --no-audio --no-border --ontop --no-input-default-bindings --no-input-cursor --no-osd-bar"

# Global state variables
MPV_PID_1=""
MPV_PID_2=""
CURRENT_DISPLAY_COUNT=0
EXPECTED_MPV_COUNT=1
LAST_DISPLAY_CHANGE=0
SCRIPT_START_TIME=$(date +%s)

# Ensure logs directory exists
mkdir -p "$LOGS_DIR"

# === LOGGING FUNCTIONS ===
log_message() {
    local level="${2:-INFO}"
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [$level] $1" | tee -a "$LOG_FILE"
}

log_config() {
    log_message "=== CONFIGURATION SUMMARY ===" "CONFIG"
    log_message "Display strategy: $DISPLAY_STRATEGY" "CONFIG"
    log_message "Dual screen config: $DUAL_SCREEN_CONFIG" "CONFIG"
    log_message "Detection interval: ${DETECTION_INTERVAL}s" "CONFIG"
    log_message "Display limits: min=$DISPLAY_MIN_COUNT, max=$DISPLAY_MAX_COUNT" "CONFIG"
    log_message "Startup sync delay: ${STARTUP_SYNC_DELAY}s" "CONFIG"
    log_message "Debounce time: ${DISPLAY_DEBOUNCE_TIME}s" "CONFIG"
}

# === VIDEO CONFIGURATION RESOLUTION ===
{% if player.schedule_enabled | default(false) and player.schedules is defined %}
# Time-based scheduling functions with day-of-week support
get_current_schedule() {
    local current_time=$(date '+%H:%M')
    local current_hour=$(date '+%H')
    local current_minute=$(date '+%M')
    local current_minutes=$((current_hour * 60 + current_minute))
    local current_dow=$(date '+%u')  # 1=Monday, 7=Sunday
    local current_day=""
    
    # Convert day number to day name
    case $current_dow in
        1) current_day="monday" ;;
        2) current_day="tuesday" ;;
        3) current_day="wednesday" ;;
        4) current_day="thursday" ;;
        5) current_day="friday" ;;
        6) current_day="saturday" ;;
        7) current_day="sunday" ;;
    esac
    
    {% for schedule in player.schedules %}
    # Schedule: {{ schedule.name }} ({{ schedule.start_time }} - {{ schedule.end_time }}){% if schedule.day_of_week is defined %} [{{ schedule.day_of_week }}]{% endif %}
    {% if schedule.day_of_week is defined %}
    # Check if this schedule matches current day
    if [ "$current_day" = "{{ schedule.day_of_week }}" ]; then
    {% else %}
    # Schedule without day restriction - always check
    {
    {% endif %}
    
    local start_time="{{ schedule.start_time }}"
    local end_time="{{ schedule.end_time }}"
    local start_hour=${start_time%:*}
    local start_minute=${start_time#*:}
    local end_hour=${end_time%:*}
    local end_minute=${end_time#*:}
    local start_minutes=$((start_hour * 60 + start_minute))
    local end_minutes=$((end_hour * 60 + end_minute))
    
    # Handle overnight schedules (e.g., 22:30 - 01:00)
    if [ $end_minutes -lt $start_minutes ]; then
        # Overnight schedule
        if [ $current_minutes -ge $start_minutes ] || [ $current_minutes -lt $end_minutes ]; then
            echo "{{ schedule.name }}"
            return 0
        fi
    else
        # Same-day schedule
        if [ $current_minutes -ge $start_minutes ] && [ $current_minutes -lt $end_minutes ]; then
            echo "{{ schedule.name }}"
            return 0
        fi
    fi
    {% if schedule.day_of_week is defined %}
    fi  # End day-specific check
    {% else %}
    }   # End schedule block
    {% endif %}
    {% endfor %}
    
    # Default fallback to first schedule that matches current day
    {% for schedule in player.schedules %}
    {% if schedule.day_of_week is defined %}
    if [ "$current_day" = "{{ schedule.day_of_week }}" ]; then
        echo "{{ schedule.name }}"
        return 0
    fi
    {% else %}
    echo "{{ schedule.name }}"
    return 0
    {% endif %}
    {% endfor %}
}

get_schedule_videos() {
    local schedule_name="$1"
    local display_num="$2"
    
    {% for schedule in player.schedules %}
    if [ "$schedule_name" = "{{ schedule.name }}" ]; then
        {% set display1_videos = schedule.videos | selectattr('display', 'equalto', 1) | selectattr('enabled', 'equalto', true) | list %}
        {% set display2_videos = schedule.videos | selectattr('display', 'equalto', 2) | selectattr('enabled', 'equalto', true) | list %}
        if [ "$display_num" = "1" ]; then
            {% if display1_videos %}
            echo "{{ display1_videos[0].name }}"
            {% else %}
            echo ""
            {% endif %}
        elif [ "$display_num" = "2" ]; then
            {% if display2_videos %}
            echo "{{ display2_videos[0].name }}"
            {% else %}
            echo ""
            {% endif %}
        fi
        return 0
    fi
    {% endfor %}
    
    echo ""
}

# Initialize video files based on current schedule
resolve_video_files() {
    local current_schedule=$(get_current_schedule)
    VIDEO_FILE_DISPLAY1="${PLAYER_DIR}/$(get_schedule_videos "$current_schedule" "1")"
    VIDEO_FILE_DISPLAY2="${PLAYER_DIR}/$(get_schedule_videos "$current_schedule" "2")"
    
    # Fallback to static configuration if scheduling fails
    if [[ -z "$(get_schedule_videos "$current_schedule" "1")" ]]; then
        {% if player.videos is defined and player.videos %}
            {% set fallback_display1 = player.videos | selectattr('display', 'equalto', 1) | selectattr('enabled', 'equalto', true) | first %}
            {% if fallback_display1 %}
        VIDEO_FILE_DISPLAY1="${PLAYER_DIR}/{{ fallback_display1.name }}"
            {% endif %}
        {% endif %}
    fi
    
    if [[ -z "$(get_schedule_videos "$current_schedule" "2")" ]]; then
        {% if player.videos is defined and player.videos %}
            {% set fallback_display2 = player.videos | selectattr('display', 'equalto', 2) | selectattr('enabled', 'equalto', true) | first %}
            {% if fallback_display2 %}
        VIDEO_FILE_DISPLAY2="${PLAYER_DIR}/{{ fallback_display2.name }}"
            {% else %}
        VIDEO_FILE_DISPLAY2="$VIDEO_FILE_DISPLAY1"  # Use same video for both displays
            {% endif %}
        {% endif %}
    fi
    
    log_message "Schedule: $current_schedule → Display1: $(basename "$VIDEO_FILE_DISPLAY1"), Display2: $(basename "$VIDEO_FILE_DISPLAY2")" "SCHEDULE"
}

# Function to check if schedule has changed and restart if needed
check_schedule_change() {
    local new_schedule=$(get_current_schedule)
    if [ "$new_schedule" != "$CURRENT_SCHEDULE" ]; then
        log_message "Schedule changed from $CURRENT_SCHEDULE to $new_schedule - updating videos" "SCHEDULE"
        CURRENT_SCHEDULE="$new_schedule"
        resolve_video_files
        return 1  # Signal video change
    fi
    return 0  # No change
}

{% else %}
# Static video configuration
resolve_video_files() {
    {% if player.videos is defined and player.videos %}
        {% set display1_videos = player.videos | selectattr('display', 'equalto', 1) | selectattr('enabled', 'equalto', true) | list %}
        {% set display2_videos = player.videos | selectattr('display', 'equalto', 2) | selectattr('enabled', 'equalto', true) | list %}
        
        # Fallback if no display-specific videos found
        {% if not display1_videos %}
            {% set display1_videos = player.videos | selectattr('enabled', 'equalto', true) | list %}
        {% endif %}
        {% if not display2_videos and display1_videos %}
            {% set display2_videos = display1_videos %}
        {% endif %}
        
        {% if display1_videos and display1_videos[0].name is defined %}
    VIDEO_FILE_DISPLAY1="${PLAYER_DIR}/{{ display1_videos[0].name }}"
        {% else %}
    log_message "ERROR: No videos configured for display 1" "ERROR"
    exit 1
        {% endif %}
        
        {% if display2_videos and display2_videos[0].name is defined %}
    VIDEO_FILE_DISPLAY2="${PLAYER_DIR}/{{ display2_videos[0].name }}"
        {% else %}
    VIDEO_FILE_DISPLAY2="$VIDEO_FILE_DISPLAY1"
        {% endif %}
    {% else %}
    log_message "ERROR: No videos configured in inventory" "ERROR"
    exit 1
    {% endif %}
    
    log_message "Static config → Display1: $(basename "$VIDEO_FILE_DISPLAY1"), Display2: $(basename "$VIDEO_FILE_DISPLAY2")" "CONFIG"
}

# No schedule checking needed for static config
check_schedule_change() {
    return 0  # No change possible
}
{% endif %}

# === ENHANCED DISPLAY DETECTION ===
# Fast, reliable display detection with multiple methods and fallbacks

detect_displays_fast() {
    local display_count=1  # Safe default
    
    # Method 1: system_profiler (most reliable but slower)
    if command -v system_profiler >/dev/null 2>&1; then
        local sp_count=$(system_profiler SPDisplaysDataType 2>/dev/null | grep -c "Resolution:" || echo "0")
        if [ "$sp_count" -gt 0 ]; then
            display_count=$sp_count
        else
            # Fallback: try counting displays via Display Type
            sp_count=$(system_profiler SPDisplaysDataType 2>/dev/null | grep -c "Display Type:" || echo "1")
            display_count=$sp_count
        fi
    fi
    
    # Method 2: osascript fallback (faster but less reliable)
    if [ "$display_count" -eq 1 ] && command -v osascript >/dev/null 2>&1; then
        local osa_count=$(osascript -e 'tell application "System Events" to get count of (every desktop)' 2>/dev/null || echo "1")
        if [ "$osa_count" -gt 1 ]; then
            display_count=$osa_count
        fi
    fi
    
    # Clamp to configured limits
    if [ "$display_count" -lt $DISPLAY_MIN_COUNT ]; then
        display_count=$DISPLAY_MIN_COUNT
    elif [ "$display_count" -gt $DISPLAY_MAX_COUNT ]; then
        display_count=$DISPLAY_MAX_COUNT
    fi
    
    echo "$display_count"
}

# Debounced display detection to handle slow-appearing displays
get_stable_display_count() {
    local current_time=$(date +%s)
    local detected_count=$(detect_displays_fast)
    
    # If display count changed, start debounce period
    if [ "$detected_count" != "$CURRENT_DISPLAY_COUNT" ]; then
        LAST_DISPLAY_CHANGE=$current_time
        log_message "Display count changed: $CURRENT_DISPLAY_COUNT → $detected_count (debouncing...)" "DISPLAY"
    fi
    
    # Check if debounce period has passed
    local time_since_change=$((current_time - LAST_DISPLAY_CHANGE))
    if [ $time_since_change -ge $DISPLAY_DEBOUNCE_TIME ]; then
        # Stable display count
        if [ "$detected_count" != "$CURRENT_DISPLAY_COUNT" ]; then
            log_message "Display count stabilized: $CURRENT_DISPLAY_COUNT → $detected_count" "DISPLAY"
            CURRENT_DISPLAY_COUNT=$detected_count
        fi
    fi
    
    echo "$CURRENT_DISPLAY_COUNT"
}

# === CONFIGURATION-DRIVEN DISPLAY LOGIC ===
# Determine expected MPV count based on strategy and configuration

calculate_expected_mpv() {
    local stable_displays="$1"
    local expected=1  # Always at least 1 (user requirement)
    
    case "$DISPLAY_STRATEGY" in
        "config")
            # Honor configuration only, ignore hardware
            if [ "$DUAL_SCREEN_CONFIG" = "true" ]; then
                expected=2
            elif [ "$DUAL_SCREEN_CONFIG" = "false" ]; then
                expected=1
            else  # auto
                expected=$([ "$stable_displays" -ge 2 ] && echo "2" || echo "1")
            fi
            ;;
        "auto")
            # Full autonomous detection, ignore configuration
            expected=$([ "$stable_displays" -ge 2 ] && echo "2" || echo "1")
            ;;
        "hybrid")
            # Configuration with runtime adjustment (recommended)
            if [ "$DUAL_SCREEN_CONFIG" = "false" ]; then
                expected=1  # Force single screen
            elif [ "$DUAL_SCREEN_CONFIG" = "true" ]; then
                # Want dual screen, but adapt to hardware
                expected=$([ "$stable_displays" -ge 2 ] && echo "2" || echo "1")
            else  # auto
                expected=$([ "$stable_displays" -ge 2 ] && echo "2" || echo "1")
            fi
            ;;
    esac
    
    echo "$expected"
}

# === MPV PROCESS MANAGEMENT ===
# Functions for managing MPV lifecycle with proper synchronization

count_running_mpv() {
    pgrep -f "mpv.*--screen=" | wc -l || echo "0"
}

get_mpv_pids() {
    pgrep -f "mpv.*--screen=" | tr '\n' ' ' || echo ""
}

# Stop all MPV instances cleanly
stop_all_mpv() {
    log_message "Stopping all MPV instances..." "STOP"
    
    # Graceful termination first
    pkill -TERM -f "mpv.*--screen=" || true
    sleep 1
    
    # Force kill if still running
    pkill -KILL -f "mpv.*--screen=" 2>/dev/null || true
    sleep 0.5
    
    # Clear PID tracking
    MPV_PID_1=""
    MPV_PID_2=""
    
    log_message "All MPV instances stopped" "STOP"
}

# Start single MPV instance
start_mpv_single() {
    local video_file="$1"
    
    log_message "Starting single-screen MPV: $(basename "$video_file")" "START"
    
    mpv --screen=0 $MPV_ARGS "$video_file" &
    MPV_PID_1=$!
    
    sleep 1
    if kill -0 $MPV_PID_1 2>/dev/null; then
        log_message "[OK] Single-screen MPV started (PID: $MPV_PID_1)" "SUCCESS"
        return 0
    else
        log_message "[NO] Single-screen MPV failed to start" "ERROR"
        MPV_PID_1=""
        return 1
    fi
}

# Start dual MPV instances with synchronization
start_mpv_dual() {
    local video1="$1"
    local video2="$2"
    
    log_message "Starting dual-screen MPV: $(basename "$video1") + $(basename "$video2")" "START"
    
    # Synchronized startup - both instances launched nearly simultaneously
    mpv --screen=0 $MPV_ARGS "$video1" &
    MPV_PID_1=$!
    
    sleep $STARTUP_SYNC_DELAY
    
    mpv --screen=1 $MPV_ARGS "$video2" &
    MPV_PID_2=$!
    
    log_message "Both MPV instances launched (PIDs: $MPV_PID_1, $MPV_PID_2)" "START"
    
    # Quick verification
    sleep 2
    
    local primary_ok=false
    local secondary_ok=false
    
    if kill -0 $MPV_PID_1 2>/dev/null; then
        log_message "[OK] Primary display running (PID: $MPV_PID_1)" "SUCCESS"
        primary_ok=true
    else
        log_message "[NO] Primary display failed" "ERROR"
        MPV_PID_1=""
    fi
    
    if kill -0 $MPV_PID_2 2>/dev/null; then
        log_message "[OK] Secondary display running (PID: $MPV_PID_2)" "SUCCESS" 
        secondary_ok=true
    else
        log_message "[NO] Secondary display failed" "ERROR"
        MPV_PID_2=""
    fi
    
    if [ "$primary_ok" = true ] && [ "$secondary_ok" = true ]; then
        log_message "[OK] DUAL-SCREEN: Both displays synchronized (PIDs: $MPV_PID_1, $MPV_PID_2)" "SUCCESS"
        return 0
    elif [ "$primary_ok" = true ]; then
        log_message "⚠ Partial success: Primary only, secondary failed" "WARNING"
        return 1
    else
        log_message "[NO] Complete failure: Both displays failed" "ERROR"
        return 2
    fi
}

# Adjust MPV instances based on expected count
adjust_mpv_instances() {
    local expected="$1"
    local current="$2"
    
    if [ "$expected" -eq "$current" ]; then
        return 0  # No change needed
    fi
    
    log_message "Adjusting MPV instances: $current → $expected" "ADJUST"
    
    # Stop all current instances
    stop_all_mpv
    
    # Start appropriate number of instances
    if [ "$expected" -eq 1 ]; then
        if start_mpv_single "$VIDEO_FILE_DISPLAY1"; then
            log_message "[OK] Adjusted to single-screen mode" "ADJUST"
        else
            log_message "[NO] Failed to adjust to single-screen mode" "ERROR"
            return 1
        fi
    elif [ "$expected" -eq 2 ]; then
        local result=0
        start_mpv_dual "$VIDEO_FILE_DISPLAY1" "$VIDEO_FILE_DISPLAY2"
        result=$?
        
        if [ $result -eq 0 ]; then
            log_message "[OK] Adjusted to dual-screen mode" "ADJUST"
        elif [ $result -eq 1 ]; then
            log_message "⚠ Partial adjustment: primary only" "ADJUST"
        else
            log_message "[NO] Failed to adjust to dual-screen mode" "ERROR"
            # Fallback to single screen
            if start_mpv_single "$VIDEO_FILE_DISPLAY1"; then
                log_message "[OK] Fallback to single-screen successful" "ADJUST"
            else
                log_message "[NO] Critical: All fallbacks failed" "ERROR"
                return 1
            fi
        fi
    fi
    
    return 0
}

# Restart crashed MPV instances
restart_failed_mpv() {
    local expected="$1"
    
    log_message "Restarting failed MPV instances..." "RESTART"
    
    # Check which instances failed
    local primary_failed=false
    local secondary_failed=false
    
    if [ -n "$MPV_PID_1" ] && ! kill -0 $MPV_PID_1 2>/dev/null; then
        primary_failed=true
        MPV_PID_1=""
    fi
    
    if [ -n "$MPV_PID_2" ] && ! kill -0 $MPV_PID_2 2>/dev/null; then
        secondary_failed=true
        MPV_PID_2=""
    fi
    
    # Restart individual instances to maintain sync
    if [ "$primary_failed" = true ]; then
        log_message "Restarting primary display..." "RESTART"
        mpv --screen=0 $MPV_ARGS "$VIDEO_FILE_DISPLAY1" &
        MPV_PID_1=$!
        
        if [ "$expected" -eq 2 ] && [ "$secondary_failed" = false ]; then
            # Need to restart secondary too for sync
            if [ -n "$MPV_PID_2" ]; then
                kill $MPV_PID_2 2>/dev/null || true
                sleep $STARTUP_SYNC_DELAY
                mpv --screen=1 $MPV_ARGS "$VIDEO_FILE_DISPLAY2" &
                MPV_PID_2=$!
                log_message "Restarted both displays for synchronization" "RESTART"
            fi
        fi
    fi
    
    if [ "$secondary_failed" = true ] && [ "$expected" -eq 2 ]; then
        log_message "Restarting secondary display..." "RESTART"
        mpv --screen=1 $MPV_ARGS "$VIDEO_FILE_DISPLAY2" &
        MPV_PID_2=$!
    fi
    
    sleep 1
    log_message "Restart complete - PIDs: ${MPV_PID_1:-none}, ${MPV_PID_2:-none}" "RESTART"
}

# === MAIN EXECUTION ===
# Cleanup function
cleanup() {
    log_message "Shutting down player..." "SHUTDOWN"
    stop_all_mpv
    log_message "Player shutdown complete" "EXIT"
    exit 0
}

# Set up signal handlers
trap cleanup SIGTERM SIGINT

# Initialize
log_message "=== OrangeAd Autonomous MPV Player Starting ===" "SYSTEM"
log_message "Hostname: $(hostname)" "SYSTEM"
log_message "User: $(whoami)" "SYSTEM"
log_config

# Resolve video files
{% if player.schedule_enabled | default(false) %}
CURRENT_SCHEDULE=$(get_current_schedule)
log_message "Schedule-based player enabled" "SYSTEM"
{% endif %}
resolve_video_files

# Validate video files exist
if [[ ! -f "$VIDEO_FILE_DISPLAY1" ]]; then
    log_message "ERROR: Primary video file not found: $VIDEO_FILE_DISPLAY1" "ERROR"
    exit 1
fi

if [[ -n "$VIDEO_FILE_DISPLAY2" && ! -f "$VIDEO_FILE_DISPLAY2" ]]; then
    log_message "WARNING: Secondary video file not found: $VIDEO_FILE_DISPLAY2, using primary" "WARNING"
    VIDEO_FILE_DISPLAY2="$VIDEO_FILE_DISPLAY1"
fi

# Clean up any existing MPV processes
log_message "Cleaning up existing MPV processes..." "CLEANUP"
stop_all_mpv

# Initial display detection with debouncing
log_message "Detecting displays..." "DISPLAY"
CURRENT_DISPLAY_COUNT=$(detect_displays_fast)
LAST_DISPLAY_CHANGE=$SCRIPT_START_TIME

# Wait for displays to stabilize
sleep $DISPLAY_DEBOUNCE_TIME
CURRENT_DISPLAY_COUNT=$(get_stable_display_count)

# Calculate initial expected MPV count
EXPECTED_MPV_COUNT=$(calculate_expected_mpv $CURRENT_DISPLAY_COUNT)

log_message "Initial state: $CURRENT_DISPLAY_COUNT display(s) detected, $EXPECTED_MPV_COUNT MPV instance(s) expected" "STATE"

# Start initial MPV instances
if [ "$EXPECTED_MPV_COUNT" -eq 1 ]; then
    if start_mpv_single "$VIDEO_FILE_DISPLAY1"; then
        log_message "[OK] Initial single-screen startup successful" "INIT"
    else
        log_message "[NO] Initial single-screen startup failed" "ERROR"
        exit 1
    fi
else
    result=0
    start_mpv_dual "$VIDEO_FILE_DISPLAY1" "$VIDEO_FILE_DISPLAY2"
    result=$?
    
    if [ $result -eq 0 ]; then
        log_message "[OK] Initial dual-screen startup successful" "INIT"
    elif [ $result -eq 1 ]; then
        log_message "⚠ Initial partial startup: primary only" "INIT"
        EXPECTED_MPV_COUNT=1  # Adjust expectation
    else
        log_message "[NO] Initial dual-screen startup failed, falling back to single" "INIT"
        if start_mpv_single "$VIDEO_FILE_DISPLAY1"; then
            EXPECTED_MPV_COUNT=1
            log_message "[OK] Fallback single-screen startup successful" "INIT"
        else
            log_message "[NO] All startup methods failed" "ERROR"
            exit 1
        fi
    fi
fi

# === AUTONOMOUS MONITORING LOOP ===
log_message "Starting autonomous monitoring (${DETECTION_INTERVAL}s intervals)..." "MONITOR"
MONITOR_COUNT=0

while true; do
    MONITOR_COUNT=$((MONITOR_COUNT + 1))
    
    # Fast display detection and debouncing
    stable_displays=$(get_stable_display_count)
    expected_mpv=$(calculate_expected_mpv $stable_displays)
    current_mpv=$(count_running_mpv)
    
    # Check for display/configuration changes
    if [ "$expected_mpv" != "$EXPECTED_MPV_COUNT" ]; then
        log_message "Display change detected: ${EXPECTED_MPV_COUNT} → ${expected_mpv} expected MPV instances" "CHANGE"
        EXPECTED_MPV_COUNT=$expected_mpv
        adjust_mpv_instances $expected_mpv $current_mpv
    elif [ "$current_mpv" != "$expected_mpv" ]; then
        # MPV instance count doesn't match expected (crash recovery)
        log_message "MPV instance mismatch: $current_mpv running, $expected_mpv expected" "MISMATCH"
        restart_failed_mpv $expected_mpv
    fi
    
    {% if player.schedule_enabled | default(false) %}
    # Check for schedule changes
    if ! check_schedule_change; then
        log_message "Video change due to schedule update" "SCHEDULE"
        # Re-resolve video files and restart if needed
        resolve_video_files
        # Force restart to pick up new videos
        adjust_mpv_instances $expected_mpv 0
    fi
    {% endif %}
    
    # Periodic health logging
    if [ $((MONITOR_COUNT % 10)) -eq 0 ]; then
        mpv_pids=$(get_mpv_pids)
        log_message "HEALTH #$MONITOR_COUNT: ${current_mpv}/${expected_mpv} MPV, ${stable_displays} displays [PIDs: ${mpv_pids:-none}]" "HEALTH"
        {% if player.schedule_enabled | default(false) %}
        log_message "Current schedule: ${CURRENT_SCHEDULE:-none}" "HEALTH"
        {% endif %}
    fi
    
    sleep $DETECTION_INTERVAL
done